/*
********************
 Batch #47
 Members:-
 			2008A7PS103 - G.Manjunath
 			2008A7PS124 - R.Maheshwar Reddy
 *********************
*/

#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include"parser.h"
#include"stackOps.h"

char tokens[62][30]={"TK_KEY_PRINT","TK_KEY_GET","TK_KEY_RETURN","TK_KEY_BEGIN","TK_KEY_END","TK_KEY_WHILE","TK_KEY_IF","TK_KEY_FUN","TK_KEY_VAR","TK_KEY_NONE","TK_KEY_IN","TK_KEY_OUT","TK_KEY_MAIN","TK_KEY_LET","TK_KEY_BE","TK_KEY_MODULO","TK_ID","TK_NUM","TK_OPEN","TK_CLOSE","TK_SEMI","TK_EQUAL","TK_NOTEQUAL","TK_LT","TK_GT","TK_LEQ","TK_GEQ","TK_COMMA","TK_COLON","e","TK_KEY_PLUS","TK_KEY_MINUS","TK_KEY_MUL","TK_KEY_DIV"," ","Programs","Functions","MainFun","OtherFuns","Funct","Parameters","InList","IDList","RemID","OutID","FunBody","Declarations","Declaration","OtherStatements","Theta","Statement","AssignmentStmt","Alpha","ExprOrFunc","Expression","FunctionCall","ConditionalStmt","BoolExp","Type","RepetitiveStmt","ReturnStmt","IO_Stmt"};

int rules[54][10]=
{{1,36},
{2,37,38},
{4,4,45,3,12},
{2,38,39},
{1,29},
{8,4,45,3,19,40,18,16,7},
{7,44,28,11,20,41,28,10},
{1,9},
{1,42},
{2,43,16},
{3,43,16,27},
{1,29},
{1,9},
{1,16},
{2,48,46},
{2,46,47},
{1,29},
{3,20,42,8},
{2,49,50},
{1,48},
{1,29},
{1,51},
{1,56},
{1,59},
{1,60},
{1,55},
{1,61},
{1,20},
{2,53,52},
{3,14,16,13},
{2,20,54},
{2,20,55},
{1,16},
{1,17},
{6,19,54,27,54,18,30},
{6,19,54,27,54,18,31},
{6,19,54,27,54,18,32},
{6,19,54,27,54,18,33},
{6,19,17,27,54,18,15},
{3,19,54,18},
{5,19,42,18,16,7},
{7,4,48,3,19,57,18,6},
{2,58,16},
{2,16,21},
{2,16,22},
{2,16,23},
{2,16,24},
{2,16,25},
{2,16,26},
{1,29},
{7,4,48,3,19,57,18,5},
{3,20,16,2},
{3,20,16,0},
{3,20,16,1}};

int parsingTable[35][35]={
{-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,2,-1,-1,-1,-1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,12,12,-1,-1,-1,-1,-1,-1,11,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,13,-1,-1,-1,-1,-1,-1,14,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{15,15,15,-1,-1,15,15,15,15,-1,-1,-1,-1,15,-1,-1,-1,-1,-1,-1,15,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{17,17,17,-1,-1,17,17,17,16,-1,-1,-1,-1,17,-1,-1,-1,-1,-1,-1,17,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,18,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{19,19,19,-1,-1,19,19,19,-1,-1,-1,-1,-1,19,-1,-1,-1,-1,-1,-1,19,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{20,20,20,-1,21,20,20,20,-1,-1,-1,-1,-1,20,-1,-1,-1,-1,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{27,27,25,-1,-1,24,23,26,-1,-1,-1,-1,-1,22,-1,-1,-1,-1,-1,-1,28,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,29,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,30,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,32,-1,-1,-1,-1,-1,-1,-1,31,31,31,31,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,31,31,31,31},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,39,33,34,40,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,35,36,37,38},
{-1,-1,-1,-1,-1,-1,-1,41,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,42,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,43,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,50,-1,44,45,46,47,48,49,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,51,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,52,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{53,54,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}};


ParseTree p;
FILE *fp;
int prSpace=0,tempsp;
int isTerminal( token_id id)
{
	return (id>33?0:1);
}

////////////////////////////////////////////////////////////////////////////////
void initializeParser(char *filename)
{
	fp=freopen(filename,"w",stdout);
	
	p=parse();
	FILE fkkk;
	//printTokenStream(fkkk);
	printParseTree(fkkk);
	fclose(fp);
}

///////////////////////////////////////////////////////////////////////////////
ParseTree parse()
{	
	extern FILE *tempFile;
	fseek(tempFile,0,SEEK_SET);
	extern char ch;
	ch=getchar();
	
	stack s;
	s=initStack(s);
	
	Token tk;
	ParseTree *pt;
	pt=malloc(sizeof(ParseTree));
	pt->root=createNode(35);
	
	treePointer curr,parent,temp;		//initial assumptions for the root node
	curr=pt->root;
	//parent=NULL;
	
	
	int tokenId,used=1,ruleNum,topId;
	s=push(s,35);
	extern int line,end;
	end=0;
	line=1;
	while(1)
	{	
		
		if(used)
		{
			tk=nextToken();
			while(tk.token_name[0]=='\0' && end==0)	//taking valid tokens i.e escaping \n \t \r
			tk=nextToken();
		}
		if(end>0)
		break;
		
		if(isEmpty(s))
		break;
		
		topId=top(s);		//top of the stack
		
		
		if(isTerminal(topId))
		{
			
			if(topId==29)	//removing e from stack
			s=pop(s);
			else
			{	
				used=1;
				if(tk.id==topId)
				{
					s=pop(s);
					curr->tk=tk;
				}
				else
				{
					end=4;
					break;
				}
			}
			while(curr!=pt->root)
			{
				if(curr->rightSib!=NULL)
				{
					curr=curr->rightSib;
					break;
				}
				else
				curr=curr->parent;
			}
		}
		else		//if its a non terminal
		{	
			used=0;
			ruleNum=parsingTable[topId-35][tk.id];
			
			if(ruleNum==-1)
			{
				end=3;
				break;
			}
			
			int len=rules[ruleNum-1][0];
			int i;
			s=pop(s);
			
			for(i=1;i<=len;i++)
			{
				s=push(s,rules[ruleNum-1][i]);
				temp=createNode(rules[ruleNum-1][i]);
				
				addNode(curr,temp);
			}
			
			curr=curr->leftChild;
		}
	}
	
	if(end==1 && isEmpty(s))
	{
		//printf("Successful\n");
		return *pt;
	}
	else
	{	
		fprintf(stderr,"end=%d error in line %d before %s %d\n",end,line,tk.token_name,topId);
		return *pt;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
void printParseTree(FILE f)		//printing postOrder 
{	
	//FILE *fp;
	//fp=&f;
	//fp=freopen("parsetree.txt","w",stdout);
	print(p.root);
	
	//fclose(fp);
}
	
void print(treePointer tp)
{	

	
	if((tp)!=NULL)
	{
		for(tempsp=prSpace;tempsp>0;tempsp--)
		printf("\t|");
		
		printf("%s\n",tokens[tp->id]);
		prSpace++;
		print(tp->leftChild);
		prSpace--;
		print(tp->rightSib);
		
	}
}
			
			
			
			
			
		
	
